# 求数组子集

```
arr = [1, 2, 3, 4...]

返回包含长度为2的所有的子集[1,2]，[2,1]算一种
```

![[Pasted image 20221207165527.png]]

## 不使用回溯

直接暴力破解

```python
res = []
for i in range(len(arr) - 1):
	for j in range(i + 1, len(arr)):
		res.append([arr[i], arr[j]])
```

如果需要长度更大例如：4、5、6，那么暴力就不够了

## 使用回溯算法

树形结构

![[Pasted image 20221207174023.png]]


**回溯三部曲**
- 1、递归函数参数返回值
	- 二维数组，保存结果
	- 一维数组，记录每次的结果
	- 数组长度
	- 组合的大小（长度）
	- 每次的开头索引（确定那些数需要）
- 2、确定终止条件
	- 每次结果的长度达到了组合大小
- 3、单层递归逻辑
	- 添加路径，然后递归，再回溯

```python
class Solution:
	def combine(self, n: int, k: int) -> List[List[int]]:
	
		res = []   # 记录结果
		temp = []  # 记录单次
	
		def back(n: int, k: int, startIndex: int):
			# 终止条件
			if len(temp) == k:
				res.append(temp[:])
				return
	
			# 单层递归逻辑
			for i in range(startIndex, n):
				temp.append(i+1)
				back(n, k, i+1)  # 递归
				temp.pop()   # 回溯，然后下一个继续加
	
		back(n, k, 0)
	
		return res
```

## 剪枝（优化）

去除回溯算法中一些不需要的

例如对于上述中`[1, 2, 3, 4]`  2的分支中是不需要1的，3的分支中是不需要1、2的，对于这些不需要的进行剪枝操作，当递归的深度非常大时，剪枝可以大大提高效率

```python
class Solution:
	def combine(self, n: int, k: int) -> List[List[int]]:
	
		res = []   # 记录结果
		temp = []  # 记录单次
	
		def back(n: int, k: int, startIndex: int):
			# 终止条件
			if len(temp) == k:
				res.append(temp[:])
				return
	
			# 单层递归逻辑
			for i in range(startIndex, n - (k - len(temp)) + 1): 
				temp.append(i+1)
				back(n, k, i+1)  # 递归
				temp.pop()   # 回溯，然后下一个继续加
	
		back(n, k, 0)
	
		return res
```

假设`n = 4, k = 4`，那么其实当`i > 1`时后面的就已经没有必要遍历

所以遍历范围不需要到达`n`，此时只需要遍历到末尾时也能符合`剩下的 + len(temp) == k`即可

那么遍历范围到`n - (k - len(temp)) + 1`即可（只需要剩下的不需要的符合）


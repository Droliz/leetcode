# 递增子序列

![[Pasted image 20221208234438.png]]

## 回溯

很容易就可以想到，只要当前的大于等于`path`末尾即可。

但是对于重复的元素，很容易想到可以直接进行判断

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
  
        res = []
        path = []
  
        def back(index):
            if path in res:
                return
            if len(path) > 1:
                res.append(path[:])
            if index == len(nums):
                return
            for i in range(index, len(nums)):
                if not path or path[-1] <= nums[i]:    
                    path.append(nums[i])
                    back(i+1)
                    path.pop()
  
        back(0)
        return res
```

其实就是一个数层去重，对于一个节点下的所有分支中，取过一个元素，那么后面相同的此元素的分支都需要剪枝

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
  
        res = []
        path = []
        s = set()
        def back(index):
            if len(path) > 1:
                res.append(path[:)

            if index == len(nums):
                return
            usage_list = [False] * 201  # 使用列表去重，题中取值范围[-100, 100]
            for i in range(index, len(nums)):
                if (path and path[-1] > nums[i]) or usage_list[nums[i] + 100]:
                    continue
                usage_list[nums[i] + 100] = True
                path.append(nums[i])
                back(i+1)
                path.pop()
  
        back(0)
        return res
```

这里采用一个数组来去重，以元素值为下标（也可以使用集合）
